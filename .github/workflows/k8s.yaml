name: Build, Push & Deploy (ARC to local k8s)

on:
  push:
    branches: ["main"]
    paths:
      - 'App/**'
  workflow_dispatch:

permissions:
  contents: read
  packages: write   # needed to push images to GHCR

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}   # owner/repo
  NAMESPACE: apps
  DEPLOYMENT: pyweb
  CONTAINER: pyweb

jobs:
  # 1) Build & push the image to GHCR on a GitHub-hosted runner
  build-and-push:
    runs-on: ubuntu-latest

    outputs:
      image: ${{ steps.vars.outputs.image }}
      tag:   ${{ steps.vars.outputs.tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive image refs
        id: vars
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" >> "$GITHUB_OUTPUT"
          echo "tag=${{ github.sha }}" >> "$GITHUB_OUTPUT"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & push (SHA + latest)
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.vars.outputs.image }}:${{ steps.vars.outputs.tag }}
            ${{ steps.vars.outputs.image }}:latest

  # 2) Deploy that image to your local cluster via ARC (runner inside your cluster)
  deploy:
    needs: build-and-push
    runs-on: arc-runner-set   # must match your ARC Runner Scale Set release name

    steps:
      - name: Checkout (for k8s manifests)
        uses: actions/checkout@v4

      - name: Install kubectl in runner
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      # Build a kubeconfig from in-cluster ServiceAccount (no kubeconfig secret needed)
      - name: Configure in-cluster kubeconfig
        shell: bash
        run: |
          set -euo pipefail
          SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
          SA_CA=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          API_SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
          kubectl config set-cluster incluster --server="${API_SERVER}" --certificate-authority="${SA_CA}"
          kubectl config set-credentials sa --token="${SA_TOKEN}"
          kubectl config set-context incluster --cluster=incluster --user=sa --namespace=${{ env.NAMESPACE }}
          kubectl config use-context incluster

      # - name: Ensure namespace exists
      #   run: |
      #     kubectl get ns ${{ env.NAMESPACE }} >/dev/null 2>&1 || kubectl create ns ${{ env.NAMESPACE }}

      - name: Apply manifests
        run: |
          kubectl -n ${{ env.NAMESPACE }} apply -f k8s/deployment.yaml

      - name: Pin Deployment to this commit's image
        run: |
          kubectl -n ${{ env.NAMESPACE }} set image deployment/${{ env.DEPLOYMENT }} \
            ${{ env.CONTAINER }}=${{ needs.build-and-push.outputs.image }}:${{ needs.build-and-push.outputs.tag }} --record

      - name: Wait for rollout & show status
        run: |
          kubectl -n ${{ env.NAMESPACE }} rollout status deployment/${{ env.DEPLOYMENT }} --timeout=180s
          kubectl -n ${{ env.NAMESPACE }} get deploy,po,svc -o wide